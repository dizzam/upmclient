#!/usr/local/bin/python3

import base64
import gzip
import json
import os
import re
import struct
import subprocess
import sys
import traceback

import requests

VERSION = "1.1.2019.509"
SCHEMA = "upm"

PVG_MAGIC = b"PVG\x00\x00\x00\x00\x00\x01\x00\x00\x00"
PNG_MAGIC = b"\x89PNG\x0d\x0a\x1a\x0a"

CUPS_BACKEND_OK = 0  # Job completed successfully
CUPS_BACKEND_FAILED = 1  # Job failed, use error-policy
CUPS_BACKEND_AUTH_REQUIRED = 2  # Job failed, authentication required
CUPS_BACKEND_HOLD = 3  # Job failed, hold job
CUPS_BACKEND_STOP = 4  # Job failed, stop queue
CUPS_BACKEND_CANCEL = 5  # Job failed, cancel job
CUPS_BACKEND_RETRY = 6  # Job failed, retry this job later
CUPS_BACKEND_RETRY_CURRENT = 7  # Job failed, retry this job immediately

ICON = "ABzY85Qu?Y0{`uhNla5=6ot<d5gfq@aRg^niXtGOR!{^dgeun70b8V69588`U{VmCR2q<B!H_PRG9;Eo+n" \
    "`XWQifK<7y>CtL#0Fv?V>V-Vqv4=qCR9;x^l_)=jP^|ySV5606{%(Z~P_A9q^%g097-VKUD-g@h@s65>yr" \
    "zLdfTXnV5*qmKHqE%!F2>fl=2CQECdlS^D8JeZud4Bh30{ys43+TU7&B-$#5OG-K$)TYP!n1iNhruFo3Ee" \
    "~n*XJK-992baAYF2^8TKPDhjz6Ae;0Mpacn3|fx<m4orPA4WNCg5;5Fg`wxv9U3Xj*envWCX**!?4@!u-R" \
    ";|TCEru7=XoMf!S<EUtb?gCKGyldto#h(bLm|uC6Y0bacRAFhH-@qrJTyZEbC6ZEb~4r-N3jMN?A~8XFs-" \
    "q3&yFXh3~^J?iS}pjNA)QmLR+Dp6Zo3xz^~>gsA#RaK#~vJ!H+95R^<QmGUb6%{BiFGpEf8A?k_QBqQZ;^" \
    "JZy6&0bNpaA*#`H)cmnwOUcu~>}U++2_(iR|obWMySRBoZMbBLhOA5CVY!>FMd<@p#~Jx!`a(V6)j^u~=X" \
    "-nP4y&NJvOPY-}uIVq&n!BL5ZEEb}sv_vrD`We?N1vrcN9fAkW<<G?BYgFBRr-{rqQhH>xiwd4CvrvUUFe" \
    "zb(!m!snnuQF4qIh}SsKJ;wTts57@x7|+$IB|hA8tqVU#3kl-{!QTGLE4efprc{OLJo(dPz&fmVX^0eckb" \
    "RB7#?wbW*t3rPxOg1CnF=H<^s8UuUxfuLjZd|-)di9-;F-Y7vg$trr6}RaLu|c6zi|dOV6z{tXUYZm}O4=" \
    "^pZbzx-pWhL|(grP)bQcA|?r`f+WZmk^o3I*%O0DQnJ<S)l;jVrqdc#DzQdA6B%-ZYC{h22P@QPM}7qW00"

args = len(sys.argv)

is_gui = False
try:
    from PyQt5.Qt import QVBoxLayout
    from PyQt5.QtCore import Qt
    from PyQt5.QtGui import QIcon, QPixmap
    from PyQt5.QtWidgets import (QApplication, QDialog, QLabel, QLineEdit,
                             QMessageBox, QPushButton)

    is_gui = True
    app = QApplication(sys.argv)
    pm = QPixmap()
    pm.loadFromData(gzip.decompress(base64.b85decode(ICON)))
    icon = QIcon(pm)
    app.setWindowIcon(icon)

    class AuthenticationDialog(QDialog):
        def __init__(self, username):
            super().__init__()
            self.password = None
            self.username = username
            self.createUI()

        def createUI(self):
            self.setWindowIcon(icon)
            self.setWindowTitle("Unifound Printing Management System")
            self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)

            l_user = QLabel("Username:", self)
            self.t_user = QLineEdit(self.username, self)

            l_pass = QLabel("Password:", self)
            self.t_pass = QLineEdit("", self)
            self.t_pass.setEchoMode(QLineEdit.Password)

            b_ok = QPushButton("Confirm", self)
            b_cancel = QPushButton("Cancel", self)

            layout = QVBoxLayout()
            self.setLayout(layout)
            layout.addWidget(l_user)
            layout.addWidget(self.t_user)
            layout.addWidget(l_pass)
            layout.addWidget(self.t_pass)
            layout.addWidget(b_ok)
            layout.addWidget(b_cancel)

            b_ok.clicked.connect(self.confirm)
            b_cancel.clicked.connect(self.cancel)

            self.show()

        def confirm(self):
            self.password = self.t_pass.text()
            self.username = self.t_user.text()
            self.close()

        def cancel(self):
            self.close()

except ImportError:
    CUPS_BACKEND_RETRY_CURRENT = CUPS_BACKEND_CANCEL


class ServerException(Exception):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class RequestException(Exception):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


def log(msg, level):
    if is_gui and level == "GUI":
        msgbox = QMessageBox()
        msgbox.setText(msg)
        msgbox.setIcon(QMessageBox.Information)
        msgbox.setWindowIcon(icon)
        msgbox.setWindowTitle("Information")
        msgbox.setWindowFlags(msgbox.windowFlags() | Qt.WindowStaysOnTopHint)
        msgbox.exec_()
    else:
        print(f"{level}: {msg}", file=sys.stderr)
        if is_gui and (level == "ERROR" or level == "WARNING"):
            msgbox = QMessageBox()
            msgbox.setText(msg)
            msgbox.setIcon(QMessageBox.Critical if level == "ERROR" else QMessageBox.Warning)
            msgbox.setWindowIcon(icon)
            msgbox.setWindowTitle(level)
            msgbox.setWindowFlags(msgbox.windowFlags() | Qt.WindowStaysOnTopHint)
            msgbox.exec_()


class APIRequest:
    def __init__(self, base_url):
        self.s = requests.session()
        self.base = base_url
        self.s.headers["Referer"] = base_url + "/driver/print.html"
        self.s.headers["User-Agent"] = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.2; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; LCTE)"

    def __parse_result(self, resp):
        if not resp.status_code == 200:
            raise ServerException(resp.request.url)

        content = json.loads(resp.content.decode())
        if not content["code"] == 0:
            raise RequestException(content["message"])

        return content

    def request(self, suburl, data):
        with self.s.post(self.base + suburl, json=data, timeout=10) as resp:
            return self.__parse_result(resp)

    def upload(self, suburl, stream, filename):
        with self.s.post(self.base + suburl, files={"szFile": (filename, stream, "application/octet-stream", {"Content-Transfer-Encoding": "binary"})}, timeout=180) as resp:
            return self.__parse_result(resp)

    def getSID(self):
        if "OSESSIONID" in self.s.cookies:
            return self.s.cookies["OSESSIONID"]

    def close(self):
        self.s.close()


def start_print(stream):
    device_uri = os.environ["DEVICE_URI"]
    job_title = sys.argv[3]

    parse = re.match(fr"{SCHEMA}://(.*)/(.*?):(.*)", device_uri)
    if parse is None:
        if not is_gui:
            log("Invalid device URI", "ERROR")
            sys.exit(CUPS_BACKEND_STOP)

        parse = re.match(fr"{SCHEMA}://([^/]*)/?(.*)", device_uri)

        dlg = AuthenticationDialog(parse.groups()[1])
        
        dlg.exec_()
        username = dlg.username
        password = dlg.password

        if password is None:
            sys.exit(CUPS_BACKEND_CANCEL)
    else:
        username = parse.groups()[1]
        password = parse.groups()[2]

    url = "http://" + parse.groups()[0]
    log(f"Username: {username}", "INFO")
    log(f"Password: {password}", "DEBUG")
    log(f"URL: {url}", "INFO")

    client = APIRequest(url)
    jobID = None
    try:
        paper = client.request("/api/client/Paper/GetPaper", data={})
        sid = client.getSID()

        log("Start Login", "INFO")
        auth = client.request("/api/client/Auth/GetAuthToken", data={"sessionid": sid})
        login = client.request("/api/client/Auth/Login", data={"szLogonName": username, "szPassword": password, "szToken": auth["szToken"], "sessionid": sid})
        client.request("/api/client/Auth/Cancel", data={"sessionid": sid, "szToken": auth["szToken"]})
        log(f"Print for {login['result']['szTrueName']}", "INFO")

        log(f"Generage Page Info", "INFO")
        data = stream.read()  # TODO: Optimizing for memory usage using os.pipe()
        preview = PVG_MAGIC
        try:
            proc = subprocess.run(["/usr/local/bin/gpcl6", "-dSAFER", "-dNOPAUSE", "-sDEVICE=pngalpha", "-sOutputFile=%stdout", "-"], stdout=subprocess.PIPE, input=data, timeout=300)
            png_data = proc.stdout

            ind = 0
            pages = 0
            suffix = b''
            png_data = png_data + b"\x00"
            while True:
                ind_new = png_data.find(PNG_MAGIC, ind + 1)

                png = base64.b64encode(png_data[ind:ind_new])
                suffix = suffix + struct.pack("<I", len(preview))
                preview = preview + struct.pack("<I", len(png)) + png

                pages = pages + 1
                if ind_new == -1:
                    break
                ind = ind_new
            preview = preview + suffix + struct.pack("<I", pages)

            proc = subprocess.run(["/usr/local/bin/gpcl6", "-dSAFER", "-dNOPAUSE", "-sDEVICE=inkcov", "-sOutputFile=%stdout", "-"], stdout=subprocess.PIPE, input=data, timeout=300)
            cmyk = proc.stdout.decode().split("\n")

            color_map = []
            for line in cmyk:
                color = re.match(r" ([\d\.]+)  ([\d\.]+)  ([\d\.]+)  ([\d\.]+) CMYK OK", line)
                if color is None:
                    log(f"Invalid output from 'inkcov': {line}", "WARNING")
                    continue
                c = float(color.groups()[0])
                m = float(color.groups()[1])
                y = float(color.groups()[2])
                k = float(color.groups()[3])

                if c == m == y == k == 0:
                    log("Skipped an empty page", "NOTICE")
                    continue
                elif c == m == y:
                    color_map.append(0)
                else:
                    color_map.append(1)
            v_pages = len(color_map)

            if v_pages == 0:
                log("No valid pages found! Set to one", "WARNING")
                color_map = [0]
                v_pages = len(color_map)

            bw_pages = color_map.count(0)
            color_pages = v_pages - bw_pages
        except Exception as e:
            log(f"Failed to get printing info: {str(e)}", "WARNING")
            color_map = [0]
            bw_pages = 1
            color_pages = 0
            pages = v_pages = 1

        log(f"Create Job [Valid Pages: {v_pages}, Color: {color_pages}, Grayscale: {bw_pages}]", "INFO")
        # TODO: Add A3 paper and single/duplex supports. Single is default now 
        # TODO: Add "切换为黑白输出" support
        job_spec = {
            "dwProperty": 0,
            "szJobName": job_title,
            "dwCopies": 1,
            "szAttribe": ("" if color_pages == 0 else "color,") + "single,collate,NUP1,",
            "szPaperDetail": json.dumps([{"dwPaperID": 9, "dwBWPages": bw_pages, "dwColorPages": color_pages, "dwPaperNum": v_pages}]),
            "szColorMap": "".join(str(i) for i in color_map),
            "OSESSIONID": sid
        }
        job = client.request("/api/client/PrintJob/Create", data=job_spec)
        jobID = job['result']['dwJobId']

        log("Upload Job", "INFO")
        gdata = gzip.compress(data)
        client.upload(f"/api/client/PrintJob/Upload?dwJobId={jobID}", gdata, "raw.dat")
        client.upload(f"/api/client/PrintJob/UploadPreview?dwJobId={jobID}", preview, "preview.pvg")

        client.request("/api/client/PrintJob/Set", data={"dwJobId": jobID, "dwStatus": 1, "OSESSIONID": sid})
        log("Printing Completed", "INFO")
        log("Printing Completed", "GUI")
        jobID = None
    except ServerException as e:
        log(f"Printing Server Error in [{str(e)}]", "ERROR")
        sys.exit(CUPS_BACKEND_RETRY)

    except RequestException as e:
        log(f"Invalid Request: {str(e)}", "ERROR")
        sys.exit(CUPS_BACKEND_RETRY_CURRENT)

    except requests.RequestException:
        log(f"Connect to Server Failed", "ERROR")
        sys.exit(CUPS_BACKEND_RETRY)

    except Exception as e:
        log(f"Backend Error: {str(e)}", "ERROR")
        tb = traceback.format_exc()
        [log(f"{i}", "ERROR") for i in tb.split("\n")]
        sys.exit(CUPS_BACKEND_STOP)

    finally:
        if jobID is not None:
            try:
                client.request("/api/client/PrintJob/Del", data={"dwJobId": jobID})
            except Exception as e:
                log(f"Failed to Remove Printing Job: {str(e)}", "ERROR")
        client.close()


if __name__ == "__main__":
    if args == 1:
        print(f"network {SCHEMA} \"Unifound\" \"Unifound Printing Backend [{VERSION}]\"")
        sys.exit(CUPS_BACKEND_OK)
    elif args == 6:
        start_print(sys.stdin.buffer)
    elif args == 7:
        with open(sys.argv[6], 'rb') as spool_file:
            start_print(spool_file)
    else:
        print("Not implemented")
        sys.exit(CUPS_BACKEND_FAILED)
